<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BabyLog</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/timezone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/plugin/relativeTime.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1/locale/ja.js"></script>
    <style>
        /* For smooth transitions */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.5s;
        }
        .fade-enter, .fade-leave-to {
            opacity: 0;
        }
        [v-cloak] {
            display: none;
        }
    </style>
</head>

<body class="bg-gray-50">

    <div id="app" v-cloak class="container mx-auto max-w-2xl p-4">

        <h1 class="text-3xl font-bold text-center text-gray-800 my-4">BabyLog</h1>

        <!-- Prediction Area -->
        <div :class="predictionBgColor" class="p-4 rounded-lg shadow-md text-center mb-6 transition-colors duration-500">
            <p class="text-xl font-semibold">{{ prediction.message }}</p>
            <p v-if="prediction.next_milk_time" class="text-lg">
                {{ formatTime(prediction.next_milk_time) }} é ƒ ({{ fromNow(prediction.next_milk_time) }})
            </p>
        </div>

        <!-- Main View (Wife Mode) -->
        <div v-if="currentView === 'main'">
            <!-- Action Buttons -->
            <div class="grid grid-cols-2 gap-4 mb-6">
                <button @click="logBreastfeeding" :class="breastfeedingClass" class="text-lg font-bold py-8 rounded-lg shadow-lg transition-colors">
                    ğŸ¤± {{ breastfeedingTimer.isActive ? 'æ¯ä¹³çµ‚äº†' : 'æ¯ä¹³é–‹å§‹' }}
                    <span v-if="breastfeedingTimer.isActive" class="block text-sm">{{ breastfeedingTimer.elapsed }}</span>
                </button>
                <button @click="logEvent('milk')" class="bg-blue-500 hover:bg-blue-600 text-white text-lg font-bold py-8 rounded-lg shadow-lg">ğŸ¼ ãƒŸãƒ«ã‚¯</button>
                <button @click="logEvent('pee')" class="bg-yellow-500 hover:bg-yellow-600 text-white text-lg font-bold py-8 rounded-lg shadow-lg">ğŸ’§ ãŠã—ã£ã“</button>
                <button @click="logEvent('poop')" class="bg-amber-700 hover:bg-amber-800 text-white text-lg font-bold py-8 rounded-lg shadow-lg">ğŸ’© ã†ã‚“ã¡</button>
                 <button @click="logEvent('pee_poop')" class="bg-lime-600 hover:bg-lime-700 text-white text-lg font-bold py-8 rounded-lg shadow-lg col-span-2">ğŸ’§ğŸ’© ä¸¡æ–¹</button>
            </div>

            <!-- Recent History -->
            <h2 class="text-xl font-semibold mb-2">ç›´è¿‘ã®è¨˜éŒ²</h2>
            <ul class="bg-white rounded-lg shadow p-4 space-y-2">
                <li v-if="latestEvents.length === 0" class="text-gray-500">è¨˜éŒ²ãŒã‚ã‚Šã¾ã›ã‚“</li>
                <li v-for="event in latestEvents" :key="event.id" class="flex justify-between items-center border-b pb-2">
                    <div>
                        <span class="font-bold">{{ getEventTypeDisplay(event.event_type) }}</span>
                        <span v-if="event.amount"> ({{ event.amount }}{{ event.event_type === 'breastfeeding' ? 'åˆ†' : 'ml' }})</span>
                        <span class="text-sm text-gray-600 ml-2">{{ formatTime(event.timestamp) }}</span>
                    </div>
                    <button @click="deleteEvent(event.id)" class="text-red-500 hover:text-red-700 text-sm">å–ã‚Šæ¶ˆã—</button>
                </li>
            </ul>
        </div>
        
        <!-- Dashboard View (Husband Mode) -->
        <div v-if="currentView === 'dashboard'">
            <h2 class="text-2xl font-bold mb-4">ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰</h2>
            <!-- Chart -->
            <div class="mb-8">
                <canvas id="eventsChart"></canvas>
            </div>

            <!-- Full Timeline -->
            <h3 class="text-xl font-semibold mb-2">å…¨å±¥æ­´</h3>
             <ul class="bg-white rounded-lg shadow p-4 space-y-2">
                <li v-for="event in allEvents" :key="event.id" class="flex justify-between items-center border-b pb-2">
                    <div>
                        <span class="font-bold">{{ getEventTypeDisplay(event.event_type) }}</span>
                         <span v-if="event.is_pee && !event.is_poop">ğŸ’§</span>
                         <span v-if="!event.is_pee && event.is_poop">ğŸ’©</span>
                         <span v-if="event.is_pee && event.is_poop">ğŸ’§ğŸ’©</span>
                        <span v-if="event.amount"> ({{ event.amount }}{{ event.event_type === 'breastfeeding' ? 'åˆ†' : 'ml' }})</span>
                        <span class="text-sm text-gray-600 ml-2">{{ formatDateTime(event.timestamp) }}</span>
                        <p v-if="event.note" class="text-sm text-gray-500">{{ event.note }}</p>
                    </div>
                    <button @click="deleteEvent(event.id)" class="text-red-500 hover:text-red-700 text-sm">å‰Šé™¤</button>
                </li>
            </ul>
        </div>

        <!-- View Switcher -->
        <div class="fixed bottom-0 left-0 right-0 bg-white shadow-lg p-2 text-center">
            <button @click="toggleView" class="text-blue-500 hover:text-blue-700 font-semibold">
                {{ currentView === 'main' ? 'ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã‚’è¦‹ã‚‹' : 'ãƒ¡ã‚¤ãƒ³ç”»é¢ã«æˆ»ã‚‹' }}
            </button>
        </div>
    </div>

<script>
    dayjs.extend(dayjs_plugin_utc);
    dayjs.extend(dayjs_plugin_timezone);
    dayjs.extend(dayjs_plugin_relativeTime);
    dayjs.locale('ja');
    dayjs.tz.setDefault("Asia/Tokyo");

    const { createApp } = Vue

    createApp({
        data() {
            return {
                prediction: { message: 'èª­ã¿è¾¼ã¿ä¸­...', next_milk_time: null },
                latestEvents: [],
                allEvents: [],
                lastMilkAmount: 120, // Default or fetched from settings
                currentView: 'main', // 'main' or 'dashboard'
                chart: null,
                breastfeedingTimer: {
                    isActive: false,
                    startTime: null,
                    intervalId: null,
                    elapsed: '00:00',
                },
                lastBreastfeedingSide: 'left', // 'left' or 'right'
            }
        },
        computed: {
            predictionBgColor() {
                if (!this.prediction.next_milk_time) return 'bg-blue-100';
                const now = dayjs();
                const nextTime = dayjs.utc(this.prediction.next_milk_time);
                const diffMinutes = nextTime.diff(now, 'minute');
                if (diffMinutes < -30) return 'bg-red-400 text-white'; // 30 mins overdue
                if (diffMinutes < 0) return 'bg-yellow-300'; // Overdue
                return 'bg-blue-100';
            },
            breastfeedingClass() {
                return this.breastfeedingTimer.isActive 
                    ? 'bg-pink-500 hover:bg-pink-600 text-white' 
                    : 'bg-pink-300 hover:bg-pink-400 text-gray-800';
            }
        },
        methods: {
            // --- UI & Formatting ---
            toggleView() {
                this.currentView = this.currentView === 'main' ? 'dashboard' : 'main';
                if (this.currentView === 'dashboard') {
                    this.fetchAllEvents();
                }
            },
            formatTime(isoString) {
                return isoString ? dayjs.utc(isoString).tz().format('HH:mm') : '';
            },
            formatDateTime(isoString) {
                return isoString ? dayjs.utc(isoString).tz().format('MM/DD HH:mm') : '';
            },
            fromNow(isoString) {
                return isoString ? dayjs.utc(isoString).tz().fromNow() : '';
            },
            getEventTypeDisplay(type) {
                const types = {
                    milk: 'ãƒŸãƒ«ã‚¯',
                    breastfeeding: 'æ¯ä¹³',
                    pee: 'ãŠã—ã£ã“',
                    poop: 'ã†ã‚“ã¡',
                    pee_poop: 'ãŠã—ã£ã“+ã†ã‚“ã¡',
                };
                return types[type] || 'ãã®ä»–';
            },

            // --- API Calls ---
            async apiCall(url, method = 'GET', body = null) {
                try {
                    const options = {
                        method,
                        headers: { 'Content-Type': 'application/json' },
                    };
                    if (body) {
                        options.body = JSON.stringify(body);
                    }
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    if (response.status === 204) return null;
                    return await response.json();
                } catch (error) {
                    console.error('API call failed:', error);
                    // Handle auth errors, e.g., redirect to login
                    if (error.message.includes('401')) {
                         window.location.href = '/login';
                    }
                }
            },
            
            async fetchPrediction() {
                this.prediction = await this.apiCall('/api/prediction');
            },

            async fetchLatestEvents() {
                const events = await this.apiCall('/api/events?limit=3');
                this.latestEvents = events || [];
                // Update last milk amount for default value
                const lastMilk = events.find(e => e.event_type === 'milk');
                if (lastMilk) {
                    this.lastMilkAmount = lastMilk.amount;
                }
            },
            
            async fetchAllEvents() {
                const events = await this.apiCall('/api/events?limit=100');
                this.allEvents = events || [];
                this.renderChart();
            },

            async logEvent(type) {
                let eventData = { event_type: type };
                if (type === 'milk') {
                    eventData.amount = this.lastMilkAmount;
                } else if (type === 'pee') {
                    eventData.is_pee = true;
                } else if (type === 'poop') {
                    eventData.is_poop = true;
                } else if (type === 'pee_poop') {
                     eventData.event_type = 'diaper';
                     eventData.is_pee = true;
                     eventData.is_poop = true;
                }
                
                await this.apiCall('/api/events', 'POST', eventData);
                this.refreshData();
            },

             async logBreastfeeding() {
                if (!this.breastfeedingTimer.isActive) {
                    // Start timer
                    this.breastfeedingTimer.isActive = true;
                    this.breastfeedingTimer.startTime = dayjs();
                    localStorage.setItem('breastfeedingStartTime', this.breastfeedingTimer.startTime.toISOString());
                    this.breastfeedingTimer.intervalId = setInterval(() => {
                        const now = dayjs();
                        const diff = now.diff(this.breastfeedingTimer.startTime);
                        const duration = dayjs.duration(diff);
                        this.breastfeedingTimer.elapsed = `${String(duration.minutes()).padStart(2, '0')}:${String(duration.seconds()).padStart(2, '0')}`;
                    }, 1000);
                } else {
                    // Stop timer and log
                    clearInterval(this.breastfeedingTimer.intervalId);
                    const endTime = dayjs();
                    const startTime = dayjs(this.breastfeedingTimer.startTime);
                    const durationMinutes = Math.round(endTime.diff(startTime, 'minute', true));
                    
                    const eventData = {
                        event_type: 'breastfeeding',
                        amount: durationMinutes > 0 ? durationMinutes : 1, // Log at least 1 minute
                        side: this.lastBreastfeedingSide,
                        timestamp: startTime.utc().toISOString(),
                    };

                    await this.apiCall('/api/events', 'POST', eventData);

                    // Reset timer and switch side
                    this.breastfeedingTimer.isActive = false;
                    this.breastfeedingTimer.elapsed = '00:00';
                    localStorage.removeItem('breastfeedingStartTime');
                    this.lastBreastfeedingSide = this.lastBreastfeedingSide === 'left' ? 'right' : 'left';
                    this.refreshData();
                }
            },

            async deleteEvent(id) {
                if (confirm('ã“ã®è¨˜éŒ²ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                    await this.apiCall(`/api/events/${id}`, 'DELETE');
                    this.refreshData();
                }
            },
            
            refreshData() {
                this.fetchPrediction();
                this.fetchLatestEvents();
                if (this.currentView === 'dashboard') {
                    this.fetchAllEvents();
                }
            },

            // --- Chart ---
            renderChart() {
                if (!this.allEvents.length) return;
                
                this.$nextTick(() => {
                    const ctx = document.getElementById('eventsChart').getContext('2d');
                    const labels = [...new Set(this.allEvents.map(e => dayjs.utc(e.timestamp).tz().format('YYYY-MM-DD')))].sort();
                    
                    const milkCounts = {};
                    const diaperCounts = {};

                    this.allEvents.forEach(event => {
                        const day = dayjs.utc(event.timestamp).tz().format('YYYY-MM-DD');
                        if (event.event_type === 'milk' || event.event_type === 'breastfeeding') {
                            milkCounts[day] = (milkCounts[day] || 0) + 1;
                        } else if (event.is_pee || event.is_poop) {
                            diaperCounts[day] = (diaperCounts[day] || 0) + 1;
                        }
                    });

                    const milkData = labels.map(label => milkCounts[label] || 0);
                    const diaperData = labels.map(label => diaperCounts[label] || 0);

                    if (this.chart) {
                        this.chart.destroy();
                    }
                    this.chart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels,
                            datasets: [{
                                label: 'æˆä¹³å›æ•°',
                                data: milkData,
                                backgroundColor: 'rgba(54, 162, 235, 0.5)',
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 1
                            }, {
                                label: 'ãŠã‚€ã¤äº¤æ›å›æ•°',
                                data: diaperData,
                                backgroundColor: 'rgba(255, 159, 64, 0.5)',
                                borderColor: 'rgba(255, 159, 64, 1)',
                                borderWidth: 1
                            }]
                        },
                        options: {
                            scales: {
                                y: { beginAtZero: true }
                            }
                        }
                    });
                });
            },
            
            checkRunningBreastfeedingTimer() {
                const savedStartTime = localStorage.getItem('breastfeedingStartTime');
                if (savedStartTime) {
                    this.breastfeedingTimer.startTime = dayjs(savedStartTime);
                    this.breastfeedingTimer.isActive = true;
                     this.breastfeedingTimer.intervalId = setInterval(() => {
                        const now = dayjs();
                        const diff = now.diff(this.breastfeedingTimer.startTime);
                        const duration = dayjs.duration(diff);
                        this.breastfeedingTimer.elapsed = `${String(duration.minutes()).padStart(2, '0')}:${String(duration.seconds()).padStart(2, '0')}`;
                    }, 1000);
                }
            }
        },
        mounted() {
            this.refreshData();
            this.checkRunningBreastfeedingTimer();
            // Refresh prediction every minute
            setInterval(this.fetchPrediction, 60000);
        }
    }).mount('#app')

</script>

</body>
</html>
